# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1erS28WuTT-2PwQ13U_ieH1nW4S3YFjs5
"""

import pandas as pd
import numpy as np
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split

games_df = pd.read_csv('/content/games.csv')
n_recommendations_df = pd.read_csv('/content/n_recommendations.csv')

# Hi·ªÉn th·ªã 5 h√†ng ƒë·∫ßu ti√™n
print(" Games Data:")
print(games_df.head())

print(" N_Recommendation Data:")
print(n_recommendations_df.head())

"""# M·ª•c m·ªõi"""

# =========================
# 2. M√£ h√≥a rating trung b√¨nh (Very Positive -> 5, ...)
# =========================
rating_map = {
    'Overwhelmingly Positive': 5.0, 'Very Positive': 4.5, 'Positive': 4.0,
    'Mostly Positive': 3.5, 'Mixed': 3.0, 'Negative': 2.5,
    'Mostly Negative': 2.0, 'Very Negative': 1.5, 'Overwhelmingly Negative': 1.0
}
games_df['rating'] = games_df['rating'].map(rating_map)

import matplotlib.pyplot as plt
import seaborn as sns

# V·∫Ω bi·ªÉu ƒë·ªì ph√¢n b·ªï rating ƒë√£ m√£ h√≥a
plt.figure(figsize=(8, 5))
sns.countplot(x='rating', data=games_df, palette='viridis',
              order=sorted(games_df['rating'].dropna().unique()))

plt.title("üìä Ph√¢n b·ªï Rating (M√£ h√≥a 1.0 - 5.0)", fontsize=14)
plt.xlabel("Rating (ƒë√£ m√£ h√≥a)", fontsize=12)
plt.ylabel("S·ªë l∆∞·ª£ng game", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# =========================
# 3. Content-based Filtering (TF-IDF tags + rating)
# =========================
games_df['tags'] = games_df['gs'].apply(lambda x: re.sub(r';', '', str(x).lower().strip()) if pd.notna(x) else '')

# TF-IDF cho tags
tfidf = TfidfVectorizer(tokenizer=lambda x: x.split(','))
tfidf_matrix = tfidf.fit_transform(games_df['tags'])
tfidf_df = pd.DataFrame.sparse.from_spmatrix(
    tfidf_matrix,
    columns=tfidf.get_feature_names_out(),
    index=games_df['id']
)

# Chu·∫©n h√≥a rating v√† th√™m v√†o TF-IDF vector
scaler = MinMaxScaler()
games_df['rating'] = scaler.fit_transform(games_df[['rating']])
tfidf_df = pd.concat([tfidf_df, games_df.set_index('id')[['rating']]], axis=1)

# =========================
# 4. Chia train/test theo user (l·∫•y 1 tr√≤ ch∆°i cu·ªëi c√πng cho test)
# =========================
train_list, test_list = [], []
for user_id, group in n_recommendations_df.groupby("user_id"):
    if len(group) >= 2:
        # L·∫•y h√†ng cu·ªëi c√πng cho test, c√°c h√†ng c√≤n l·∫°i cho train
        train = group.iloc[:-1]
        test = group.iloc[-1:]
    else:
        # N·∫øu ch·ªâ c√≥ 1 tr√≤ ch∆°i, ƒë∆∞a v√†o train, test r·ªóng
        train = group
        test = pd.DataFrame(columns=group.columns)
    train_list.append(train)
    test_list.append(test)

train_df = pd.concat(train_list)
test_df = pd.concat(test_list)
print(f"‚úÖ Train size: {len(train_df)}, Test size: {len(test_df)}")

# =========================
# 5. X√¢y d·ª±ng Item-based Collaborative Filtering
# =========================
user_game_matrix = train_df.pivot_table(index='user_id', columns='id', aggfunc=len, fill_value=0)
item_sim_matrix = cosine_similarity(user_game_matrix.T)
item_sim_df = pd.DataFrame(item_sim_matrix, index=user_game_matrix.columns, columns=user_game_matrix.columns)

def get_item_based_cf(user_id, train_df, k=10):
    bought_games = train_df[train_df['user_id'] == user_id]['id'].tolist()
    bought_games = [g for g in bought_games if g in item_sim_df.index]
    if not bought_games:
        return pd.DataFrame(columns=['id', 'score'])
    sim_scores = item_sim_df[bought_games].mean(axis=1)
    sim_scores = sim_scores.drop(index=bought_games)
    scores_df = sim_scores.sort_values(ascending=False).head(k).reset_index()
    scores_df.columns = ['id', 'score']
    return scores_df

# =========================
# 6. Content-based Recommendation
# =========================
def get_content_based(user_id, train_df, tfidf_df, k=10):
    bought_ids = train_df[train_df['user_id'] == user_id]['id'].tolist()
    if not bought_ids:
        return pd.DataFrame(columns=['id', 'score'])
    mean_vector = tfidf_df.loc[bought_ids].mean(axis=0).to_numpy().reshape(1, -1)
    sim_scores = cosine_similarity(mean_vector, tfidf_df)[0]
    scores_df = pd.DataFrame({'id': tfidf_df.index, 'score': sim_scores})
    scores_df = scores_df[~scores_df['id'].isin(bought_ids)].sort_values(by='score', ascending=False).head(k)
    return scores_df

# =========================
# 7. Hybrid Recommendation (CBF + CF)
# =========================
def get_hybrid(user_id, alpha=0.5, k=10):
    cb_scores = get_content_based(user_id, train_df, tfidf_df, k*2)
    cf_scores = get_item_based_cf(user_id, train_df, k*2)
    hybrid_df = pd.merge(cb_scores, cf_scores, on='id', how='outer', suffixes=('_cb', '_cf')).fillna(0)
    hybrid_df['score'] = hybrid_df['score_cb'] * alpha + hybrid_df['score_cf'] * (1-alpha)
    hybrid_df = hybrid_df.sort_values(by='score', ascending=False).head(k)
    return games_df.merge(hybrid_df, on='id')[['id', 'title', 'score']]

# ƒê·ªãnh nghƒ©a h√†m tokenizer thay cho lambda
def custom_tokenizer(x):
    return x.split(',')

# TF-IDF cho tags (kh√¥ng d√πng lambda)
tfidf = TfidfVectorizer(tokenizer=custom_tokenizer)
tfidf_matrix = tfidf.fit_transform(games_df['tags'])

import pickle

with open("trained_models.pkl", "wb") as f:
    pickle.dump({
        "tfidf": tfidf,
        "tfidf_df": tfidf_df,
        "scaler": scaler,
        "item_sim_df": item_sim_df,
        "games_df": games_df,
        "train_df": train_df
    }, f)